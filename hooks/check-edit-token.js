#!/usr/bin/env node
/**
 * PreToolUse Hook - Edit/Write Token Validator
 *
 * This hook runs BEFORE every Edit/Write operation and checks for a valid token
 * that was GENERATED BY AN AGENT (Explore, Plan, etc.).
 *
 * ENFORCEMENT CHAIN:
 *   Agent Completion â†’ Token Generated â†’ Edit/Write Allowed
 *
 * There is NO manual way to generate tokens. This creates an unbreakable
 * requirement to use agents before making code changes.
 *
 * Exit codes:
 *   0 = Allow the operation (valid agent-generated token found)
 *   Non-zero = Block the operation (no token, expired, or not agent-generated)
 *
 * Environment: Claude Code passes tool input via stdin as JSON
 */

const fs = require('fs');
const path = require('path');

// State files go in hooks-state (local), not hooks (synced via OneDrive)
const STATE_DIR = path.join(process.env.USERPROFILE || process.env.HOME, '.claude', 'hooks-state');
const TOKEN_FILE = path.join(STATE_DIR, 'edit_token.json');
const STATE_FILE = path.join(STATE_DIR, 'enforcement_state.json');

// Ensure state directory exists
if (!fs.existsSync(STATE_DIR)) {
    fs.mkdirSync(STATE_DIR, { recursive: true });
}

// Maximum edits allowed before testing is required
const MAX_EDITS_BEFORE_TEST = 5;

// Files that are exempt from the protocol (hook files themselves, temporary files)
const EXEMPT_PATTERNS = [
    /\.claude[\\/]hooks[\\/]/,       // Hook files
    /\.claude[\\/]hooks-state[\\/]/, // State files
    /edit_token\.json$/,             // Token file itself
    /enforcement_state\.json$/,      // State file
    /[\\/]temp[\\/]/,                // Temp directories
    /[\\/]\.tmp/,                    // Temp files
    /[\\/]node_modules[\\/]/,        // Node modules
];

// Read stdin for tool input
async function readStdin() {
    return new Promise((resolve) => {
        let data = '';
        process.stdin.setEncoding('utf8');

        process.stdin.on('readable', () => {
            let chunk;
            while ((chunk = process.stdin.read()) !== null) {
                data += chunk;
            }
        });

        process.stdin.on('end', () => {
            resolve(data);
        });

        // Handle case where stdin is empty or not provided
        setTimeout(() => {
            if (!data) resolve('{}');
        }, 100);
    });
}

// Check if file path is exempt
function isExempt(filePath) {
    if (!filePath) return false;
    return EXEMPT_PATTERNS.some(pattern => pattern.test(filePath));
}

// Load and validate token
function loadToken() {
    try {
        if (!fs.existsSync(TOKEN_FILE)) {
            return {
                valid: false,
                reason: 'No edit token found.',
                hint: 'You must run an Explore or Plan agent first to get edit permission.'
            };
        }

        const content = fs.readFileSync(TOKEN_FILE, 'utf8');
        const token = JSON.parse(content);

        // CRITICAL: Check that token was generated by an agent, not manually
        if (token.source !== 'agent-completion') {
            return {
                valid: false,
                reason: 'Token was not generated by an agent.',
                hint: 'Manual tokens are not accepted. Run an Explore or Plan agent first.'
            };
        }

        // Check if already used
        if (token.used) {
            return {
                valid: false,
                reason: 'Token already used.',
                hint: `Previous edit used token from ${token.grantedBy} agent. Run another agent for new edits.`
            };
        }

        // Check expiration
        const expiresAt = new Date(token.expiresAt);
        if (new Date() > expiresAt) {
            return {
                valid: false,
                reason: `Token expired at ${token.expiresAt}.`,
                hint: 'Run an Explore or Plan agent to get a fresh token.'
            };
        }

        return { valid: true, token };
    } catch (err) {
        return {
            valid: false,
            reason: `Failed to read token: ${err.message}`,
            hint: 'Run an Explore or Plan agent to generate a valid token.'
        };
    }
}

// Consume the token (mark as used)
function consumeToken(token) {
    try {
        token.used = true;
        token.usedAt = new Date().toISOString();
        fs.writeFileSync(TOKEN_FILE, JSON.stringify(token, null, 2));
    } catch (err) {
        // Log but don't fail - token was valid
        console.error(`Warning: Could not mark token as used: ${err.message}`);
    }
}

// Load enforcement state
function loadEnforcementState() {
    try {
        if (fs.existsSync(STATE_FILE)) {
            return JSON.parse(fs.readFileSync(STATE_FILE, 'utf8'));
        }
    } catch (err) {}
    return {
        editsSinceTest: 0,
        needsTesting: false,
        needsSecurityReview: false,
        securitySensitiveEdits: []
    };
}

// Check if testing gate should block
function checkTestingGate() {
    const state = loadEnforcementState();

    // Block if too many edits without testing
    if (state.editsSinceTest >= MAX_EDITS_BEFORE_TEST) {
        return {
            blocked: true,
            reason: `${state.editsSinceTest} edits made without testing.`,
            hint: 'Run qa-test-engineer agent to validate changes before more edits.',
            editCount: state.editsSinceTest
        };
    }

    // Warn but don't block if security-sensitive files need review
    if (state.needsSecurityReview && state.securitySensitiveEdits?.length > 0) {
        return {
            blocked: false,
            warning: `Security-sensitive files edited: ${state.securitySensitiveEdits.map(f => path.basename(f)).join(', ')}`,
            hint: 'Consider running elite-security-auditor agent.'
        };
    }

    return { blocked: false };
}

// Main execution
async function main() {
    try {
        // Read tool input from stdin
        const input = await readStdin();
        let toolInput = {};

        try {
            toolInput = JSON.parse(input);
        } catch {
            // If no JSON input, proceed with validation
        }

        // Get the file path being edited/written
        const filePath = toolInput.file_path || toolInput.filePath || '';

        // Check if this file is exempt
        if (isExempt(filePath)) {
            // Allow without token for exempt files
            process.exit(0);
        }

        // FIRST: Check testing gate (blocks if too many edits without testing)
        const testGate = checkTestingGate();
        if (testGate.blocked) {
            console.log('');
            console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
            console.log('â•‘      ğŸ§ª EDIT BLOCKED - TESTING REQUIRED ğŸ§ª                   â•‘');
            console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('');
            console.log(`âŒ Reason: ${testGate.reason}`);
            console.log(`ğŸ’¡ Hint: ${testGate.hint}`);
            console.log('');
            console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
            console.log('â”‚                    TESTING GATE ACTIVE                       â”‚');
            console.log('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');
            console.log('â”‚                                                             â”‚');
            console.log(`â”‚  You have made ${testGate.editCount} edits without running tests.        â”‚`);
            console.log('â”‚  This increases the risk of introducing bugs.              â”‚');
            console.log('â”‚                                                             â”‚');
            console.log('â”‚  To continue editing, run:                                  â”‚');
            console.log('â”‚  â€¢ qa-test-engineer agent - To test your changes           â”‚');
            console.log('â”‚                                                             â”‚');
            console.log('â”‚  This resets the edit counter and reopens the gate.        â”‚');
            console.log('â”‚                                                             â”‚');
            console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
            console.log('');
            process.exit(1);
        }

        // Load and validate token
        const result = loadToken();

        if (!result.valid) {
            console.log('');
            console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
            console.log('â•‘       ğŸš« EDIT/WRITE BLOCKED - NO AGENT PERMISSION ğŸš«         â•‘');
            console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('');
            console.log(`âŒ Reason: ${result.reason}`);
            if (result.hint) {
                console.log(`ğŸ’¡ Hint: ${result.hint}`);
            }
            console.log('');
            console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
            console.log('â”‚              AGENT-ENFORCED DEVELOPMENT PROTOCOL            â”‚');
            console.log('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');
            console.log('â”‚                                                             â”‚');
            console.log('â”‚  Before editing code, you MUST run one of these agents:    â”‚');
            console.log('â”‚                                                             â”‚');
            console.log('â”‚  â€¢ Explore agent - To understand the codebase              â”‚');
            console.log('â”‚  â€¢ Plan agent    - To design the implementation            â”‚');
            console.log('â”‚                                                             â”‚');
            console.log('â”‚  These agents will:                                        â”‚');
            console.log('â”‚  1. Research the relevant code                             â”‚');
            console.log('â”‚  2. Trace the execution flow                               â”‚');
            console.log('â”‚  3. Generate an edit token upon completion                 â”‚');
            console.log('â”‚                                                             â”‚');
            console.log('â”‚  There is NO manual way to get edit permission.            â”‚');
            console.log('â”‚  This ensures you understand before you change.            â”‚');
            console.log('â”‚                                                             â”‚');
            console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
            console.log('');

            // Exit with non-zero to BLOCK the operation
            process.exit(1);
        }

        // Token is valid - consume it and allow the operation
        consumeToken(result.token);

        // Get current state for info
        const state = loadEnforcementState();

        console.log('');
        console.log('âœ… Edit permission validated and consumed');
        console.log(`   ğŸ¤– Granted by: ${result.token.grantedBy} agent`);
        console.log(`   ğŸ“ Task: ${result.token.taskDescription || 'N/A'}`);
        console.log(`   ğŸ”‘ Token: ${result.token.id}`);
        console.log(`   ğŸ“Š Edits since last test: ${state.editsSinceTest}/${MAX_EDITS_BEFORE_TEST}`);

        // Show warnings if needed
        if (testGate.warning) {
            console.log('');
            console.log(`   âš ï¸  ${testGate.warning}`);
            console.log(`   ğŸ’¡ ${testGate.hint}`);
        }

        console.log('');

        // Exit 0 to ALLOW the operation
        process.exit(0);

    } catch (err) {
        console.error(`Hook error: ${err.message}`);
        // On error, block the operation to be safe
        process.exit(1);
    }
}

main();
